
const express = require("express");
const fetch = require("node-fetch");
require("dotenv").config();
const nano = require("nano");
const app = express();
const couch_database = nano(process.env.COUCHDB_URL);
const sessions = require("express-session");

app.use(express.json());
const the_database = couch_database.db.use('final_year_project');
app.use(express.static("public"));

    app.use(sessions({
        secret : "the-secret-key",
        saveUninitialized : false,
        resave : false,
        cookie : {secure:false}
    }));

    app.post("/user_login", async (request,response) => {
        
        try
        {
            const match = await the_database.find
            ({
            selector: {
            
                username:request.body.username,
                password:request.body.password
            
            }});
            if(!match.docs || match.docs.length === 0)
            {
                return response.json({success:false,message:"no matching username and password found"});
            }
            request.session.username = request.body.username;
            return response.json({success:true , message:"found matching username and password"});
        }
        catch(err)
        {
            console.log("failed to retrieve username and password",err);
            response.status(500).end("error retrieving data");
        }
    })

    // retrieve the latest recommendation from the database
    app.get("/retrieve-recommendations", async(request,response)=>
    {
        try{
            // find all documents in the database where
            const query = await the_database.find({
                selector:
                {
                    date_inserted: {$exists : true},
                    api_prompt: {"$exists": true },
                    username: request.session.username // the user prompt exists
                },
                fields:
                [
                    "recomm_text",
                    "date_inserted" // only the output field is retrieved
                ],
                sort:
                 [
                    { date_inserted: "desc" } // sorted by id in descending order
                 ],
                    limit: 3 // enforce a limit of 1 to show only the latest recommendation
                
            });
            // if there are no documents or the document length is 0
            if(!query.docs || query.docs.length < 3)
            {
                console.log("not enough documents found");
                return response.json({ output: "Not enough recommendations found" });
            }
            // set the response as the first result document generated by running the query
            const retrieved_response = query.docs[0];
            const retrieved_response2 = query.docs[1];
            const retrieved_response3 = query.docs[2];
            // send the response to the frontend
           response.json({ output: retrieved_response.recomm_text,output2:retrieved_response2.recomm_text,output3:retrieved_response3.recomm_text });
           

        }catch(err){
            console.log("failed to retrieve recommendations from the database",err);
            return;
        };
    });

    app.post("/register_details", async (request,response)=>
    {
        const username = request.body.username;
        const password = request.body.password;
        const email = request.body.email;
        try
        {
            await the_database.insert({username:username,password:password,email:email});
            console.log("Inserted user's personal details into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/idea_details", async (request,response)=>
    {
        const ideas = request.body.ideas;
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,ideas:ideas});
            console.log("Inserted user's idea list into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(500).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/product_details", async (request,response)=>
    {
        const products = request.body.products
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,products:products});
            console.log("Inserted user's product portfolio into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/generate_recommendations",async (request,response) => 
    {
            try {
                const username = request.body.username;
                const products = request.body.products;
                const ideas = request.body.ideas;

                const the_products = JSON.stringify(products);
                const the_ideas = JSON.stringify(ideas);


                const api_prompt  = `For this SaaS startup, generate 3 distinct product/service ideas numbered from 1-3 based on this portfolio: ${the_products} and these ideas: ${the_ideas}`;
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "openrouter/auto", messages: [
            { role: "system", content: "none" },
            { role: "user", content: api_prompt } // sends the user prompt

            ], max_tokens: 90 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            const message = result?.choices?.[0]?.message; 
            const response_content = message.reasoning_details?.[0]?.summary?.trim() || message.reasoning?.trim() || message.content?.trim();

            const regex = /\n?\s*\d\.\s+/;
            const three_parts = response_content.split(regex);

            const parts_array = [];
            for( let i=0;i<three_parts.length;i++)
            {
                if(three_parts[i] != "")
                {
                    parts_array.push(three_parts[i].trim());
                }
            }
            // insert the formatted response and the user prompt into the database
            for(let i = 0;i<parts_array.length;i++){
            await the_database.insert({ username,api_prompt,recomm_text: parts_array[i], date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,api_prompt, part:i+1});
            }
            // if no content is included in the response
            if(parts_array.length === 0)
            {
                console.log("content is empty");
            }
            else
            {
                // return the content to the front-end in JSON form
                response.json({output: parts_array});
            }
            } catch (err) {
                console.error("Error inserting prompt to database",err);
            }
        
        });

        app.listen(3000, ()=>
        {
            console.log("listening on port 3000")
        }
        );
    app.post("/retrieve_full_summary",async (request,response) =>
    {
        try {
                const username = request.session.username;
                const summary = request.body.summary;

                const database_check = await the_database.find({selector: {username,summary},limit: 3});

                if(database_check.docs.length >= 3)
                {
                    return response.json({output1:database_check.docs[0].expanded_text,output2:database_check.docs[1].expanded_text,output3:database_check.docs[2].expanded_text});
                }
          

                const full_summary_prompt  = `For this SaaS startup,expand on each of these product/service summaries: ${summary} and give a short risk assessment of implementing these product/services under the headings: Market conditions,Potential Cost, Size of potential market, Uniqueness of Product idea, Overall Risk Grading(low,medium,high) and provide the links for the sources of information you got`;
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "anthropic/claude-3.5-sonnet", messages: [
            { role: "system", content: "Expand on SaaS product/service idea summary and include risk assessment" },
            { role: "user", content: full_summary_prompt } // sends the user prompt

            ], max_tokens: 360 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            const message = result?.choices?.[0]?.message; 
            const expanded_summary = message.reasoning_details?.[0]?.summary?.trim() || message.reasoning?.trim() || message.content?.trim();

            const regex = /\n?\s*\d\.\s+/;
            const three_parts = expanded_summary.split(regex);

            const parts_array = [];
            for( let i=0;i<three_parts.length;i++)
            {
                if(three_parts[i] != "")
                {
                    parts_array.push(three_parts[i].trim());
                }
            }
            // insert the formatted response and the user prompt into the database
            for(let i = 0;i<parts_array.length;i++){
            await the_database.insert({ username,full_summary_prompt,summary, expanded_text: parts_array[i], date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,full_summary_prompt,expanded_text});
            }
            // if no content is included in the response
            if(parts_array.length ===0)
            {
                console.log("content is empty");
            }
            else
            {
                // return the content to the front-end in JSON form
                 return response.json({output: parts_array});
            }
            } catch (err) {
                console.error("Error inserting prompt to database",err);
            }
        
        });
    app.get("/retrieve_full_summary", async (request,response)=>
    {
        try{
        const query = await the_database.find({
            
            selector:
            {
                username: request.session.username,
                summary: request.query.summary// the user prompt exists
            },
            fields:
            [
                "expanded_text" // only the output field is retrieved
            ],
                limit: 3 // enforce a limit of 1 to show only the latest recommendation
            
        });
        // if there are no documents or the document length is 0
        if(!query.docs || query.docs.length < 3)
        {
            console.log("not enough documents found");
            return response.json({ output: "recommendations not available",found:false });
        }
        // set the response as the first result document generated by running the query
        const retrieved_response = query.docs[0];
        const retrieved_response2 = query.docs[1];
        const retrieved_response3 = query.docs[2];
        // send the response to the frontend
         return response.json({ output1: retrieved_response.expanded_text,output2: retrieved_response2.expanded_text,output3:retrieved_response3.expanded_text});
         
        

    }catch(err){
        console.log("failed to retrieve recommendations from the database",err);
        return;
    };
    })
    app.post("/logout", async (request,response) =>
    {
        try
        {
            request.session.destroy(err =>{
                if(!err)
                {
                    return response.json({success:true})
                }
                return response.status(500).json({ error: "Failed to process logout" });
            })
        }
        catch(err)
        {
            console.log("Failed end user session",err);
            return response.status(400).end("logout unsuccessful: bad request");
        }
    })
    






