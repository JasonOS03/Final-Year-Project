
const express = require("express");
const fetch = require("node-fetch");
const cookieparser = require('cookie-parser');
require("dotenv").config();
const nano = require("nano");
const app = express();
const couch_database = nano(process.env.COUCHDB_URL);
const sessions = require("express-session");
const couch_store = require("connect-couchdb")(sessions);

app.use(express.json());
const the_database = couch_database.db.use('final_year_project');
app.use(cookieparser());

    const couchUrl = new URL(process.env.COUCHDB_URL);

app.use(
  sessions({
    secret: "the-secret-key",
    saveUninitialized: false,
    resave: false,
    store: new couch_store({
      name: "sessions",
      host: couchUrl.hostname,
      port: couchUrl.port || 5984,
      protocol: couchUrl.protocol.replace(":", ""),
      username: couchUrl.username,
      password: couchUrl.password
    }),
    cookie: { secure: false }
  })
);


    app.use(express.static("public"));

    console.log("COUCHDB_URL:", process.env.COUCHDB_URL);
    


    app.post("/user_login", async (request,response) => {
        
        try
        {
            const match = await the_database.find
            ({
            selector: {
            
                username:request.body.username,
                password:request.body.password
            
            }});
            if(!match.docs || match.docs.length === 0)
            {
                return response.json({success:false,message:"no matching username and password found"});
            }
            request.session.username = request.body.username;
            return response.json({success:true , message:"found matching username and password"});
        }
        catch(err)
        {
            console.log("failed to retrieve username and password",err);
            response.status(500).end("error retrieving data");
        }
    })

    // retrieve the latest recommendation from the database
    app.get("/retrieve-recommendations", async(request,response)=>
    {
        try{
            // find all documents in the database where
            const query = await the_database.find({
                selector:
                {
                    date_inserted: {$exists : true},
                    api_prompt: {"$exists": true },
                    username: request.session.username // the user prompt exists
                },
                fields:
                [
                    "recomm_text",
                    "date_inserted",
                    "id"// only the output field is retrieved
                ],
                sort:
                 [
                    { date_inserted: "desc" } // sorted by id in descending order
                 ],
                    limit: 3 // enforce a limit of 1 to show only the latest recommendation
                
            });
            // if there are no documents or the document length is 0
            if(!query.docs || query.docs.length < 3)
            {
                console.log("not enough documents found");
                return response.json({ output: "Not enough recommendations found" });
            }
            // set the response as the first result document generated by running the query
            const retrieved_response = query.docs[0];
            const retrieved_response2 = query.docs[1];
            const retrieved_response3 = query.docs[2];
            // send the response to the frontend
           response.json({ output:
            [
                 {recomm_text:retrieved_response.recomm_text ,id:retrieved_response.id},
                 {recomm_text:retrieved_response2.recomm_text,id:retrieved_response2.id},
                {recomm_text:retrieved_response3.recomm_text,id:retrieved_response3.id}
            ]
        });
           

        }catch(err){
            console.log("failed to retrieve recommendations from the database",err);
            return;
        };
    });

    app.post("/register_details", async (request,response)=>
    {
        const username = request.body.username;
        const password = request.body.password;
        const email = request.body.email;
        try
        {
            await the_database.insert({username:username,password:password,email:email});
            console.log("Inserted user's personal details into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/idea_details", async (request,response)=>
    {
        const ideas = request.body.ideas;
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,ideas:ideas});
            console.log("Inserted user's idea list into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(500).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/product_details", async (request,response)=>
    {
        const products = request.body.products
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,products:products});
            console.log("Inserted user's product portfolio into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/generate_recommendations",async (request,response) => 
    {
            try {
                const username = request.body.username;
                const products = request.body.products;
                const ideas = request.body.ideas;

                const the_products = JSON.stringify(products);
                const the_ideas = JSON.stringify(ideas);


                const api_prompt  = `For this SaaS startup, 
                generate exactly 3 distinct product/service ideas numbered from 1-3 
                in the following format: 
                1. idea 1 here
                2. idea 2 here
                3. idea 3 here
                 based on this portfolio: ${the_products}
                  and these ideas: ${the_ideas}. when displaying your ideas, only use the exact formatting specified above and no other type of formatting. 
                  other rules you must follow are:
                  1. The output must not include summaries, intros or conclusions
                  2. Exactly three unique recommendations must be generated
                  3. no text can be added between each idea
                  4. Markdown must not be used
                  5. Do not combine the ideas into one idea
                  6. do not add any text, whitespace of blank lines before each idea
                  7. do not add any text before the list of ideas or after the list`;
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "openrouter/auto", messages: [
            { role: "system", content: "none" },
            { role: "user", content: api_prompt } // sends the user prompt

            ], max_tokens: 90 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            const message = result?.choices?.[0]?.message; 
            const response_content = message.reasoning_details?.[0]?.summary?.trim() || message.reasoning?.trim() || message.content?.trim();

            const regex = /\n\s*(?=\d\.\s)/; 
            const three_parts = response_content.split(regex); 
            const parts_array = three_parts .map(p => p.trim()) .filter(p => /^\d\.\s/.test(p));

            for( let i=0;i<three_parts.length;i++)
            {
                if(three_parts[i] != "")
                {
                    parts_array.push(three_parts[i].trim());
                }
            }
            // insert the formatted response and the user prompt into the database
            for(let i = 0;i<parts_array.length;i++){
            await the_database.insert({ username,api_prompt,recomm_text: parts_array[i],id: i, date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,api_prompt, part:i+1});
            }
            // if no content is included in the response
            if(parts_array.length === 0)
            {
                console.log("content is empty");
            }
            else
            {
                // return the content to the front-end in JSON form
                response.json({output: parts_array});
            }
            } catch (err) {
                console.error("Error inserting prompt to database",err);
            }
        
        });

        app.listen(3000, ()=>
        {
            console.log("listening on port 3000")
        }
        );
    app.post("/retrieve_full_summary",async (request,response) =>
    {
        console.log("retrieve_full_summary route HIT");
        console.log("username:", request.session.username);
        console.log("summary:", request.body.summary);
        console.log("id:", request.body.id);


        try {
                const username = request.session.username;
                const summary = request.body.summary;
                const id = Number(request.body.id);

                const database_check = await the_database.find(
                    {
                        selector: {username,id:Number(id)}
                    
                });

                if(database_check.docs.length === 1 && database_check.docs[0].expanded_text)
                {
                    return response.json({output: database_check.docs[0].expanded_text});
                }
          

              const full_summary_prompt =
`Expand the following SaaS product/service idea showing a detailed analysis.

Product/service Idea:
${summary}

You MUST output the expansion in EXACTLY this format:
1. Expanded Idea: <text>
Market Conditions: <text>
Potential Cost: <text>
Size of Potential Market: <text>
Uniqueness of Product Idea: <text>
Overall Risk Grading: <low/medium/high>
Sources: <links>

RULES:
- Do NOT add any text before "1." or after the final "Sources:" line.
- Do NOT use markdown formatting.
- The content "Overall Risk Grading" field must be either low, medium or high
- Do NOT add summaries, intros, or conclusions.
- Do NOT change the heading names.
- Do NOT add blank lines anywhere.
`;


                // post the user prompt to the OpenRouter API
                console.log("Sending request to OpenRouter...");

                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model:"meta-llama/llama-3.1-8b-instruct", messages: [
            { role: "system", content: "Expand on SaaS product/service idea summary and include risk assessment" },
            { role: "user", content: full_summary_prompt } // sends the user prompt

            ], max_tokens: 360 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }
        


            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            let expanded_summary =
            result?.choices?.[0]?.message?.content ||
            result?.choices?.[0]?.text ||
            "";

            expanded_summary = String(expanded_summary).trim();



            console.log("Returning expanded summary:", expanded_summary);

            // insert the formatted response and the user prompt into the database
            const the_id = id;

            if(database_check.docs.length === 1)
            {
                    database_check.docs[0].full_summary_prompt = full_summary_prompt;
                    database_check.docs[0].expanded_text = expanded_summary;
                    database_check.docs[0].date_inserted = new Date().toISOString();
                    await the_database.insert(database_check.docs[0]);
            }
            else
            {

            await the_database.insert({ username,full_summary_prompt,summary, expanded_text: expanded_summary,id: the_id,date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,full_summary_prompt,expanded_text:expanded_summary});
            }
                // return the content to the front-end in JSON form
                 return response.json({output: expanded_summary});
            } catch (err) {
                console.error("Error: ",err);
                return response.status(500).json({ error: "Backend failure", details: err.message }); 
            }
        
        });
    app.post("/logout", async (request,response) =>
    {
        try
        {
            request.session.destroy(err =>{
                if(!err)
                {
                    return response.json({success:true})
                }
                return response.status(500).json({ error: "Failed to process logout" });
            })
        }
        catch(err)
        {
            console.log("Failed end user session",err);
            return response.status(400).end("logout unsuccessful: bad request");
        }
    })
    app.get("/debug-session", (req, res) => { res.json({ cookie: req.headers.cookie, session: req.session }); });
    






