const express = require("express");
const fetch = require("node-fetch");
const cookieparser = require('cookie-parser');
require("dotenv").config();
const nano = require("nano");
const app = express();
const couch_database = nano(process.env.COUCHDB_URL);
const sessions = require("express-session");
const couch_store = require("connect-couchdb")(sessions);

app.use(express.json());
const the_database = couch_database.db.use('final_year_project');
app.use(cookieparser());

    const couchUrl = new URL(process.env.COUCHDB_URL);

app.use(
  sessions({
    secret: "the-secret-key",
    saveUninitialized: false,
    resave: false,
    store: new couch_store({
      name: "sessions",
      host: couchUrl.hostname,
      port: couchUrl.port || 5984,
      protocol: couchUrl.protocol.replace(":", ""),
      username: couchUrl.username,
      password: couchUrl.password
    }),
    cookie: { secure: false }
  })
);


    app.use(express.static("public"));

    console.log("COUCHDB_URL:", process.env.COUCHDB_URL);
    


    app.post("/user_login", async (request,response) => {
        
        try
        {
            const match = await the_database.find
            ({
            selector: {
            
                username:request.body.username,
                password:request.body.password
            
            }});
            if(!match.docs || match.docs.length === 0)
            {
                return response.json({success:false,message:"no matching username and password found"});
            }
            request.session.username = request.body.username;
            return response.json({success:true , message:"found matching username and password"});
        }
        catch(err)
        {
            console.log("failed to retrieve username and password",err);
            response.status(500).end("error retrieving data");
        }
    })

    // retrieve the latest recommendation from the database
    app.get("/retrieve-recommendations", async(request,response)=>
    {
        try{
            // find all documents in the database where
            const query = await the_database.find({
                selector:
                {
                    date_inserted: {$exists : true},
                    api_prompt: {"$exists": true },
                    username: request.session.username // the user prompt exists
                },
                fields:
                [
                    "recomm_text",
                    "date_inserted",
                    "id"// only the output field is retrieved
                ],
                sort:
                 [
                    { date_inserted: "desc" } // sorted by id in descending order
                 ],
                
            });
            // if there are no documents or the document length is 0
            if(!query.docs)
            {
                console.log("not enough documents found");
                return response.json({ output: "Not enough recommendations found" });
            }
            // set the response as the first result document generated by running the query
            const value_array = []; 
            const deduplicated_values = query.docs.filter(doc => 
                { 
                    if (value_array.includes(doc.recomm_text))
                    { 
                        return false;
                    }; 
                    value_array.push(doc.recomm_text); 
                    return true; 
                }); 

                const unique_dates = new Set(deduplicated_values.map(doc => doc.date_inserted)).size;

                let limit = 3 + (unique_dates - 1);

                const shrink_limit = deduplicated_values.slice(0, limit);

                return response.json({ output: shrink_limit });



        }catch(err){
            console.log("failed to retrieve recommendations from the database",err);
            return;
        };
    });

    app.post("/register_details", async (request,response)=>
    {
        const username = request.body.username;
        const password = request.body.password;
        const email = request.body.email;
        try
        {
            await the_database.insert({username:username,password:password,email:email});
            console.log("Inserted user's personal details into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/idea_details", async (request,response)=>
    {
        const ideas = request.body.ideas;
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,ideas:ideas});
            console.log("Inserted user's idea list into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(500).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/product_details", async (request,response)=>
    {
        const products = request.body.products
        const username = request.body.username;
        try
        {
            await the_database.insert({username:username,products:products});
            console.log("Inserted user's product portfolio into the database");
            response.json({success: true, message: "data saved successfully"})
        }
        catch(err)
        {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
        }
    })

    app.post("/competitor_details",async(request,response)=>{
            const competitors = request.body.competitors;
            const username = request.body.username;
            try
            {
            await the_database.insert({username:username,competitors:competitors});
            console.log("Inserted user's competitor details into the database");
            response.json({success: true, message: "data saved successfully"})
            }
            catch(err)
            {
            console.error("error inserting the data into the database",err);
            response.status(400).end("data unsuccessfully inserted into database");
            }
    })

    app.post("/generate_recommendations",async (request,response) => 
    {
            try {
                const username = request.body.username;
                const products = request.body.products;
                const ideas = request.body.ideas;

                const the_products = JSON.stringify(products);
                const the_ideas = JSON.stringify(ideas);


                const api_prompt  = `For this SaaS startup, 
                generate exactly 3 distinct product/service ideas numbered from 1-3 
                in the following format: 
                1. idea 1 here
                2. idea 2 here
                3. idea 3 here
                 based on this portfolio: ${the_products}
                  and these ideas: ${the_ideas}. when displaying your ideas, only use the exact formatting specified above and no other type of formatting. 
                  other rules you must follow are:
                  1. The output must not include summaries, intros or conclusions
                  2. Exactly three unique recommendations must be generated
                  3. no text can be added between each idea
                  4. Markdown must not be used
                  5. Do not combine the ideas into one idea
                  6. do not add any text, whitespace of blank lines before each idea
                  7. do not add any text before the list of ideas or after the list`;
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "openrouter/auto", messages: [
            { role: "system", content: "none" },
            { role: "user", content: api_prompt } // sends the user prompt

            ], max_tokens: 90 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            const message = result?.choices?.[0]?.message; 
            const response_content = message.reasoning_details?.[0]?.summary?.trim() || message.reasoning?.trim() || message.content?.trim();

            const regex = /\n\s*(?=\d\.\s)/; 
            const three_parts = response_content.split(regex); 
            const parts_array = three_parts .map(p => p.trim()) .filter(p => /^\d\.\s/.test(p));

            for( let i=0;i<three_parts.length;i++)
            {
                if(three_parts[i] != "")
                {
                    parts_array.push(three_parts[i].trim());
                }
            }
            // insert the formatted response and the user prompt into the database
            for(let i = 0;i<parts_array.length;i++){
            await the_database.insert({ username,api_prompt,recomm_text: parts_array[i],id: i, date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,api_prompt, part:i+1});
            }
            // if no content is included in the response
            if(parts_array.length === 0)
            {
                console.log("content is empty");
            }
            else
            {
                // return the content to the front-end in JSON form
                response.json({output: parts_array});
            }
            } catch (err) {
                console.error("Error inserting prompt to database",err);
            }
        
        });
    app.post("/get_competitor_data",async (request,response)=>{
        try
        {
            const username = request.session.username
            const competitors = request.body.competitors;
            const ideas = request.body.ideas;
            const products = request.body.products;
            const id = Number(request.body.id);
            const check_comp = await the_database.find(
                {
                    selector:
                    {
                        username:username,
                        competitors: {"$exists":true}
                    },
                    fields:
                    [
                        "competitors"
                    ]
                }
            )
            if(check_comp.docs.length > 0)
                {
                    return response.json({output: check_comp.docs[0].competitors});
                }


            const summary_query = await the_database.find(
                {
                    selector: 
                    {
                        username:username,
                        recomm_text:{"$exists":true}
                    },
                    fields:
                    [
                        "recomm_text",
                        "date_inserted"
                    ],
                    sort:
                    [
                        {date_inserted:"desc"}
                    ]
                }
            );

                const the_summaries =  summary_query.docs.map(doc => doc.recomm_text);

        
            const competitor_data_prompt = `Based on the following product/service recommendations for this SaaS startup: ${the_summaries.join("\n")} 
            and these user entered competitors: ${competitors}
            and the following product/service ideas entered by the SaaS startup: ${ideas}
            and the following product portfolio entered by the startup: ${products} 
            find and display between 3-6 SaaS company names which are potential competitors with the following structure:
            Competitor <number>:
            Competitor Name: <competitor name>
            Market Position: <(New Entrant, Small/Niche, Established or Market Leader)>
                Product 1:
                Product Name: <product name>
                Product Price(Estimated): <range>
                Product Market Share(Estimated): <percentage expressed as an integer or decimal without symbols>
                Items Sold/Number of Users: <integer>
                Categories: <comma separated>
              
                  1. The output must not include summaries, intros or conclusions
                  2. The market share must be expressed as a percentage
                  3. no text can be added between each listed product
                  4. Markdown must not be used
                  5. Do not create new metrics that were not specified
                  5. do not add any text, whitespace of blank lines before each competitor or product belonging to that
                  6. do not add any text before the list of competitors or after the list
                  7. Categories listed must match the categories from the user's product portfolio
                  8. Each Competitor must have exactly one unique product/service listed
                  `;



                
            

            const competitor_data = await call_api(competitor_data_prompt);
            return response.json({competitor_data:competitor_data});
        }
        catch(err)
        {
            console.error("Error: ",err);
            return response.status(500).json({ error: "Backend failure", details: err.message }); 

        }
    })

    app.post("/retrieve_full_summary",async (request,response) =>
    {
        console.log("retrieve_full_summary route HIT");
        console.log("username:", request.session.username);
        console.log("summary:", request.body.summary);
        console.log("id:", request.body.id);


        try {
                const username = request.session.username;
                const summary = request.body.summary;
                const id = Number(request.body.id);

                const database_check = await the_database.find(
                    {
                        selector: {username,id:Number(id)}
                    
                });

                if(database_check.docs.length === 1 && database_check.docs[0].expanded_text)
                {
                    return response.json({output: database_check.docs[0].expanded_text});
                }
          

              const full_summary_prompt =
`Expand the following SaaS product/service idea showing a detailed analysis.

Product/service Idea:
${summary}

You MUST output the expansion in EXACTLY this format:
1. Expanded Idea: <text>
Market Conditions: <text>
Potential Cost: <text>
Size of Potential Market: <text>
Uniqueness of Product Idea: <text>
Overall Risk Grading: <low/medium/high>
Sources: <links>

RULES:
- Do NOT add any text before "1." or after the final "Sources:" line.
- Do NOT use markdown formatting.
- The content "Overall Risk Grading" field must be either low, medium or high
- Do NOT add summaries, intros, or conclusions.
- Do NOT change the heading names.
- Do NOT add blank lines anywhere.
`;


                // post the user prompt to the OpenRouter API
                console.log("Sending request to OpenRouter...");

                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model:"meta-llama/llama-3.1-8b-instruct", messages: [
            { role: "system", content: "Expand on SaaS product/service idea summary and include risk assessment" },
            { role: "user", content: full_summary_prompt } // sends the user prompt

            ], max_tokens: 360 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            return response.status(resp.status).json({ error: error_text });
        }
        


            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            let expanded_summary =
            result?.choices?.[0]?.message?.content ||
            result?.choices?.[0]?.text ||
            "";

            expanded_summary = String(expanded_summary).trim();



            console.log("Returning expanded summary:", expanded_summary);

            // insert the formatted response and the user prompt into the database
            const the_id = id;

            if(database_check.docs.length === 1)
            {
                    database_check.docs[0].full_summary_prompt = full_summary_prompt;
                    database_check.docs[0].expanded_text = expanded_summary;
                    database_check.docs[0].date_inserted = new Date().toISOString();
                    await the_database.insert(database_check.docs[0]);
            }
            else
            {

            await the_database.insert({ username,full_summary_prompt,summary, expanded_text: expanded_summary,id: the_id,date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,full_summary_prompt,expanded_text:expanded_summary});
            }
                // return the content to the front-end in JSON form
                 return response.json({output: expanded_summary});
            } catch (err) {
                console.error("Error: ",err);
                return response.status(500).json({ error: "Backend failure", details: err.message }); 
            }
        
        });
    app.post("/logout", async (request,response) =>
    {
        try
        {
            request.session.destroy(err =>{
                if(!err)
                {
                    return response.json({success:true})
                }
                return response.status(500).json({ error: "Failed to process logout" });
            })
        }
        catch(err)
        {
            console.log("Failed end user session",err);
            return response.status(400).end("logout unsuccessful: bad request");
        }
    })

    app.get("/retrieve_details",async (request,response) =>{
        try{
        let user = request.session.username;
        console.log("RAW SESSION USER:", user);

        user = user.trim().toLowerCase();
        console.log("SESSION USER:", JSON.stringify(user));
         const ideas_query = await the_database.find({
          selector:
          {
                 username : user
                 
          },
          fields:
          [
                "ideas",
                "username"
          ]
        });
        const product_query = await the_database.find({
            selector:
          {
                 username : user
                 
          },
          fields:
          [
                "products",
                "username"
          ]
        });

        const personal_details_query = await the_database.find({
            selector:
            {
                username: user
            },
            fields:
            [
                "username",
                "password",
                "email"
            ]
        });
        const competitors_query = await the_database.find({
          selector:
          {
                 username : user
                 
          },
          fields:
          [
                "competitors",
                "username"
          ]
        });
        const ideas_document = ideas_query.docs.find(d => d.ideas);
        const products_document = product_query.docs.find(d => d.products);
        const competitors_document = competitors_query.docs.find(d=>d.competitors)
        console.log("IDEAS QUERY RAW:", ideas_query); console.log("PRODUCT QUERY RAW:", product_query);
        return response.json({username: personal_details_query.docs[0]?.username || "",
            password: personal_details_query.docs[0]?.password || "",email:personal_details_query.docs[0]?.email || "",ideas: ideas_document?.ideas || [] , 
            products : products_document?.products || [],
            competitors : competitors_document?.competitors || []})
    }
    catch
    {
        return response.status(500).json({error: "Could not retrieve the user's idea list,product portfolio or entered competitor details"});
    }
    }
)
app.post("/update_profile",async (request,response) =>{

            try{
                 const user = request.session.username;
           const ideas_query = await the_database.find({
            selector:
            {
                    username : user
                 
            },
            fields:
            [
                "_id",
                "_rev",
                 "ideas",
                "username"
            ]
            });
            const product_query = await the_database.find({
                selector:
             {
                    username : user
                 
            },
            fields:
            [
                    "_id",
                    "_rev",
                    "products",
                    "username"
            ]
            });
            const competitor_query = await the_database.find({
                selector:
             {
                    username : user
                 
            },
            fields:
            [
                    "_id",
                    "_rev",
                    "competitors",
                    "username"
            ]
            });
           

        const ideas_document = ideas_query.docs.find(d => d.ideas !== undefined);
        const products_document = product_query.docs.find(d => d.products !== undefined);
        const competitors_document = competitor_query.docs.find(comp => comp.competitors !== undefined);
        const old_ideas = ideas_document?.ideas || [];
        const old_products = products_document?.products || [];
        const old_competitors = competitors_document?.competitors || [];
        let changed =  false;

        const new_ideas = request.body.ideas;
        const new_products =  request.body.products;
        const new_competitors = request.body.competitors

        if(old_ideas.length !== new_ideas.length || old_products.length !== new_products.length || old_competitors.length !== new_competitors.length )
        {
            changed = true;
        }
        if(changed){
            await generate_new_recommendation(user,new_products,new_ideas);
        }
        ideas_document.ideas = new_ideas;
        products_document.products = new_products;
        competitors_document.competitors = new_competitors;
        await the_database.insert(ideas_document);
        await the_database.insert(products_document);
        await the_database.insert(competitors_document);

        return response.json({success:true});

    }
    catch
    {
        return response.status(500).json({error: "Could not retrieve the user's idea list or product portfolio"});
    } 
    });
        async function generate_new_recommendation(username,products,ideas){
             try {

                const the_products = JSON.stringify(products);
                const the_ideas = JSON.stringify(ideas);


                const api_prompt  = `For this SaaS startup, 
                generate exactly 1 distinct product/service idea 
                in the following format: 
                1. idea 1 here
                 based on this portfolio: ${the_products}
                  and these ideas: ${the_ideas}. when displaying your ideas, only use the exact formatting specified above and no other type of formatting. 
                  other rules you must follow are:
                  1. The output must not include summaries, intros or conclusions
                  2. Exactly one unique recommendations must be generated
                  3. Markdown must not be used
                  4. do not add any text, whitespace of blank lines before the idea
                  `;
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "openrouter/auto", messages: [
            { role: "system", content: "none" },
            { role: "user", content: api_prompt } // sends the user prompt

            ], max_tokens: 30 }) // sets a maximum token limit 

        });
        console.log("OpenRouter response status:", resp.status);

        if (!resp.ok) 
        {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            throw new Error(error_text);
        }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);
            // parse the response and extract the text content

            const message = result?.choices?.[0]?.message; 
            const response_content = message.reasoning_details?.[0]?.summary?.trim() || message.reasoning?.trim() || message.content?.trim();

            const regex = /\n\s*(?=\d\.\s)/; 
            const split_recomm = response_content.split(regex); 
            const formatted_recomm = split_recomm.map(p => p.trim()) .filter(p => /^\d\.\s/.test(p));
            // insert the formatted response and the user prompt into the database
            
            await the_database.insert({ username,api_prompt,recomm_text: formatted_recomm[0], date_inserted: new Date().toISOString()});
            console.log("Inserted document:", { username,api_prompt,formatted_recomm});
            
            // if no content is included in the response
            if(formatted_recomm.length === 0)
            {
                console.log("content is empty");
            }
            else
            {
                // return the content to the front-end in JSON form
                return formatted_recomm[0];
            }
            } catch (err) {
                console.error("Error inserting prompt to database",err);
                throw err;
            }
        }
       
         async function call_api(prompt)
        {
                // post the user prompt to the OpenRouter API
                const resp = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                    "Authorization": "Bearer " + process.env.OPENROUTER_API_KEY,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "http://localhost:3000", 
                    "X-Title": "SaaS Idea Generator"
                    
                    },
                    body: JSON.stringify(
                        // indicates the AI model used
                        {  model: "openrouter/auto", messages: [
            { role: "system", content: "none" },
            { role: "user", content: prompt } // sends the user prompt

            ], max_tokens: 30 }) // sets a maximum token limit 

            });
            console.log("OpenRouter response status:", resp.status);

            if (!resp.ok) 
            {
            const error_text = await resp.text();
            console.error("Model API error:", error_text);
            throw new Error(error_text);
            }

            // asynchronously wait for the JSON response
            const result = await resp.json();
            console.log("OpenRouter result: ",result);

            let competitor_result =
            result?.choices?.[0]?.message?.content ||
            result?.choices?.[0]?.text ||
            "";
            return competitor_result;
        }
         if(require.main === module){
        app.listen(3000, ()=>
        {
            console.log("listening on port 3000")
        }
        );
    }
    module.exports = app;